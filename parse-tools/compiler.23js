const fs = require("fs");
const path = require("path");

const START_TOKEN = "***start***";
const END_TOKEN = "***end***";

const compileFiles = (dirPath, outputFile) => {
  let compiledContent = "";

  const traverseDirectory = (dir) => {
    // console.log(
    //   `PMM - SF - compiler.js - traverseDirectory - current dir is: ${JSON.stringify(
    //     dir
    //   )}`
    // );
    fs.readdirSync(dir).forEach((file) => {
      const filePath = path.join(dir, file);
      if (fs.statSync(filePath).isDirectory()) {
        traverseDirectory(filePath); // Recursive call for directories
      } else {
        const fileContent = fs.readFileSync(filePath, "utf8");
        const relativePath = path.relative(__dirname, filePath);
        compiledContent += `${START_TOKEN}\n${relativePath}\n${fileContent}\n${END_TOKEN}\n\n`;
        console.log(
          `PMM - SF - compiler.js - traverseDirectory - writing current compiledContent`
        );
        // console.log(
        //   `PMM - SF - compiler.js - traverseDirectory - current compiledContent is: ${JSON.stringify(
        //     compiledContent
        //   )}`
        // );
      }
    });
  };

  traverseDirectory(dirPath);

  try {
    fs.writeFileSync(outputFile, compiledContent);
  } catch (error) {
    console.error("Error writing the compiled file:", error.message);
  }
};

// Checking for correct number of command-line arguments
if (process.argv.length !== 4) {
  console.error(
    "Usage: node compiler.js <path-to-folder-structure> <fully-qualified-output-file.js>"
  );
  process.exit(1);
}

// Setting environment variables (optional, modify as needed)
// process.env.MY_ENV_VARIABLE = 'value';

// Retrieving directory path and output file from command-line arguments
const dirPath = process.argv[2];
const outputFile = process.argv[3];

// Calling the function with the provided arguments
compileFiles(dirPath, outputFile);
